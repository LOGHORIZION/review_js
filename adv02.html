<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>prototype</title>
</head>
<body>
<!--
1. 函数的prototype属性(图)
  * 每个函数都有一个prototype属性, 它默认指向一个Object空对象(即称为: 原型对象)
  * 原型对象中有一个属性constructor, 它指向函数对象
2. 给原型对象添加属性(一般都是方法)
  * 作用: 函数的所有实例对象自动拥有原型中的属性(方法)


1. 每个函数function都有一个prototype，即显式原型(属性)
2. 每个实例对象都有一个__proto__，可称为隐式原型(属性)
3. 对象的隐式原型的值为其对应构造函数的显式原型的值
4. 内存结构(图)
5. 总结:
  * 函数的prototype属性: 在定义函数时自动添加的, 默认值是一个空Object对象
  * 对象的__proto__属性: 创建对象时自动添加的, 默认值为构造函数的prototype属性值
  * 程序员能直接操作显式原型, 但不能直接操作隐式原型(ES6之前)
-->
<script>
  function Toy(){
// 内部语句: this.prototype = {}

  }
  console.log(Toy.prototype);
  console.log(Toy.prototype.constructor == Toy);//true
  //给原型对象添加属性(一般是方法) ===>实例对象可以访问
  Toy.prototype.property= function(){
    // alert('!');
  }
  let t1 = new Toy();// //new 内部语句: this.__proto__ = Toy.prototype
  t1.property();
  //3. 实例对象t1的隐式原型__proto__的值为其对应构造函数Toy的显式原型prototype的值
  console.log(t1.__proto__ ==Toy.prototype);
  console.log(t1.__proto__);
  console.log(t1.__proto__.__proto__);
  console.log(t1.__proto__.__proto__ ===Object.prototype);
  //Object的原型对象是原型链尽头
  console.log( Object.prototype.__proto__); // null
  console.log(t1.test3 === undefined);
  console.log(Toy.__proto__);
  function f2(){

  }
  console.log(Toy.__proto__ === f2.__proto__  );
  //所有定义的函数的隐式原型都是一样的
  console.log('所有定义的函数的隐式原型都是一样的');
  console.log(Toy.__proto__ ===  Function.prototype );
  console.log(Function.prototype);
  console.log(Function.prototype.__proto__);
  console.log(Object.prototype);
  //证明了 函数是特殊的对象
  console.log(Function.prototype.__proto__ === Object.prototype);

  console.log(Toy.prototype instanceof Object);//true
  //只有 Object的 prototype 不是 Object的实例
  //任何实例对象的原型对象都指向了Object的原型对象
  console.log(Object.prototype instanceof Object);// false
  console.log( Function.__proto__ ===Toy.__proto__);
  // 所有函数（包括Function 本身 都是Function的实例）；
  console.log( Function.__proto__ ===Function.prototype);//true
  console.log( Function instanceof Function);

</script>
</body>
</html>